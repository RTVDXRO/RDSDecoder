#!/usr/bin/python
"""
  This will read in CSV-formatted records and generate the equivalent C code.
  Used for generating the C code version of the ISO 14819-2 event list and
  supplementary information strings.

  Arguments:
    $1: one of 'events' or 'supplementary'
    $2: source file to read in, CSV format, no header row. For both values of
        $1, the field order mimics the one in the standard, as follows:
      'events': event code, event text, event nature, event qualifier, event
                time horizon, event directionality, event urgency, event update
                class and event text reference phrases.
      'supplementary': supplementary information code, supplementary information
                       text.
  NOTE: this code makes assumptions about (1) the contents of iso14819-2.h and
        (2) the order of inclusion of said header with respect to the generated
        one.
"""

import csv
import re
import sys

WORK_TYPES = ['events', 'supplementary']
OUTPUT_STRINGS = {'firstline': {
                      'events': 'event list',
                      'supplementary': 'supplementary information'},
                  'varname': {
                      'events': 'TRDSTMCEventListEntry ISO14819_2_Events',
                      'supplementary': 'TRDSTMCSupplementaryEntry '
                                       'ISO14819_2_Supplementary'},
                  'storage': {
                      'events': 'WITH_RDS_TMC_EVENT_STRINGS_',
                      'supplementary': 'WITH_RDS_TMC_SUPPLEMENTARY_STRINGS_'}}
QUANTIFIER_PREFIX = 'RDS_TMC_QUANTIFIER_'
NATURE_PREFIX = 'RDS_TMC_NATURE_'
URGENCY_PREFIX = 'RDS_TMC_URGENCY_'
QUANTIFIERS = ['SMALL_NUMBER', 'NUMBER', 'LESSTHAN_METERS', 'PERCENT',
               'UPTO_KMH', 'UPTO_MINUTES', 'DEGREES_CELSIUS', 'TIME', 'TONNES',
               'METERS', 'UPTO_MILLIMETERS', 'MHZ', 'KHZ']
NATURES = {'': 'INFORMATION', 'F': 'FORECAST', 'S': 'SILENT'}
URGENCIES = {'': 'NORMAL', 'U': 'URGENT', 'X': 'XURGENT'}
FIND_Q = re.compile(r'([(][^(]*)(Q)([^)]*[)])')
REPLACE_Q = r'\1%s\3'
FIND_BRACE = re.compile(r'[{][^}]*[}]')


def PostProcessString(s):
  return re.sub(FIND_BRACE, '', re.sub(FIND_Q, REPLACE_Q, s)).strip()


def OutputStringPointer(fout, index, offset, worktype):
  fout.write('#if defined(%sFLASH)\n' % OUTPUT_STRINGS['storage'][worktype])

  if worktype == 'events':
    fout.write(', Event_S_%04X\n' % index)
  else:
    fout.write(', Supplementary_S_%02X\n' % index)

  fout.write(
    '#elif defined(%sEEPROM)\n, (const char * const) 0x%04X\n'
    '#endif\n' % (OUTPUT_STRINGS['storage'][worktype], offset))


def main(argv):
  if len(argv) != 3:
    print ('Invalid calling convention, need exactly two arguments but got '
           '%d!' % (len(argv) - 1))
    exit(1)
  if argv[1] not in WORK_TYPES:
    print ('Invalid calling convention, argv[1] must be one of %s but got '
           '"%s"!' % (WORK_TYPES, argv[1]))
    exit(1)

  if argv[1] == 'events':
    fname_out = 'iso14819-2-events.h'
    fname_eeprom = 'iso14819-2-events.eeprom'
  else:
    fname_out = 'iso14819-2-supplementary.h'
    fname_eeprom = 'iso14819-2-supplementary.eeprom'
  eeprom_offset = 0

  with open(argv[2], 'rb') as fin, open(fname_out, 'w') as fout,\
      open(fname_eeprom, 'wb') as feeprom:
    table = list(csv.reader(fin))
    fout.write(
        '/*\n * ISO 14819-2 header file: %(firstline)s entries\n'
        ' * DO NOT EDIT: automatically generated by gentables.py from CSV files'
        '\n */\n\n'
        '#ifndef _%(fname)s_INCLUDED\n#define _%(fname)s_INCLUDED\n'
        '#ifdef WITH_RDS_TMC_%(worktype)s\n\n' % {
            'firstline': OUTPUT_STRINGS['firstline'][argv[1]],
            'fname': fname_out.upper().replace('-','_').replace('.','_'),
            'worktype': argv[1].upper()})

    fout.write('#if defined(%sFLASH)\n' % OUTPUT_STRINGS['storage'][argv[1]])
    for row in table:
      fout.write('const char %s_S_%s[] PROGMEM = "%s";\n' % (
          'Event' if argv[1] == 'events' else 'Supplementary',
          '%04X' % int(row[0]) if argv[1] == 'events' else '%02X' % int(row[0]),
          PostProcessString(row[1])))
      feeprom.write('%s\x00' % PostProcessString(row[1]))
    fout.write('#endif\n')

    fout.write('\nconst %(varname)s[%(count)d] PROGMEM = {\n' % {
            'varname': OUTPUT_STRINGS['varname'][argv[1]],
            'count': len(table)})

    if argv[1] == 'events':
      for row in table:
        fout.write('\t{0x%04X, %s, %s, %s, %s, %s, %s, %s\n' % (
            int(row[0]),
            '%s%s' % (QUANTIFIER_PREFIX, QUANTIFIERS[int(row[3])]),
            '%s%s' % (NATURE_PREFIX, NATURES[row[2]]),
            '%s%s' % (URGENCY_PREFIX, URGENCIES[row[6]]),
            'true' if 'L' in row[4] else 'false',
            'true' if '(' in row[4] or row[3] == '7' else 'false',
            'true' if row[5] == '2' else 'false',
            row[7]))
        OutputStringPointer(fout, int(row[0]), eeprom_offset, argv[1])
        eeprom_offset += len(PostProcessString(row[1])) + 1;
        fout.write('},\n')
    else:
      for row in table:
        fout.write('\t{0x%02X\n' % int(row[0]))
        OutputStringPointer(fout, int(row[0]), eeprom_offset, argv[1])
        eeprom_offset += len(PostProcessString(row[1])) + 1;
        fout.write('},\n')

    fout.write('};\n\n#endif\n#endif')


if __name__ == '__main__':
  main(sys.argv)